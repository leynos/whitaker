# Extend installer to download and verify prebuilt artefacts (roadmap 3.4.4)

This ExecPlan is a living document. The sections Constraints, Tolerances,
Risks, Progress, Surprises & Discoveries, Decision Log, and
Outcomes & Retrospective must be kept up to date as work proceeds.

Status: COMPLETE

This document must be maintained in accordance with AGENTS.md.

The canonical plan file is `docs/execplans/3-4-4-install-prebuilt-artefacts.md`.

## Purpose / big picture

The Whitaker installer currently builds every Dylint lint library locally,
which is slow. ADR-001 specifies a download-first, compile-second approach:
before local compilation the installer should attempt to download a prebuilt
`.tar.zst` archive from the GitHub rolling release, verify its SHA-256
checksum against an external manifest, and extract the libraries to the
staging directory. On any failure (network, checksum, missing artefact,
unsupported target) it falls back to local compilation with a warning.

After this change a user on a supported platform running
`whitaker-installer` will see the installer download prebuilt libraries in
seconds rather than compiling for minutes. Users on unsupported platforms
or behind firewalls will see a warning and the existing build path runs
unchanged.

## Constraints

- All changes confined to the `installer/` crate, CI workflow, and docs.
- Public interfaces of existing modules must remain stable.
- Must pass `make check-fmt`, `make lint`, and `make test`.
- No file may exceed 400 lines.
- Artefact newtypes must validate during deserialization (no bypassing
  `TryFrom` via bare `#[derive(Deserialize)]`).
- en-GB-oxendict spelling in all comments and documentation.
- Caret requirements for all dependencies.
- rstest-bdd v0.5.0 mutable world pattern for BDD tests.
- The prebuilt attempt must never be fatal — all failures produce a
  fallback to local compilation.

## Tolerances (exception triggers)

- Scope: if implementation requires changes to more than 25 files or
  500 net lines, stop and escalate.
- Interface: if a public API signature of an existing module must change
  in a breaking way, stop and escalate.
- Dependencies: one new external dependency (`ureq`) is pre-approved;
  any additional external dependency requires escalation.
- Iterations: if tests still fail after 5 attempts at a fix, stop and
  escalate.
- Ambiguity: if a design choice materially affects the user-visible
  behaviour and multiple valid interpretations exist, stop and present
  options.

## Risks

- Risk: `manifest.json` is not currently uploaded as a release asset
  in CI. The installer cannot download manifests without this fix.
  Severity: high. Likelihood: certain (confirmed by reading the workflow).
  Mitigation: include the CI fix in this plan (rename to
  `manifest-<target>.json`, upload alongside archives).

- Risk: `ureq` v3 may introduce API differences from v2 that require
  adaptation.
  Severity: low. Likelihood: low.
  Mitigation: pin to `ureq = "3"` with caret requirement; consult docs
  during implementation.

- Risk: `manifest.rs` is already ~402 lines. Adding `Deserialize` may
  push it over the 400-line limit.
  Severity: low. Likelihood: medium.
  Mitigation: extract tests to `manifest_tests.rs` using the
  `#[path = ...]` pattern already established by `packaging.rs`.

- Risk: `tempfile` is only a dev-dependency. The prebuilt download
  pipeline needs it at runtime for download-then-verify.
  Severity: low. Likelihood: certain.
  Mitigation: promote `tempfile` to a regular dependency.

## Progress

- [x] Phase 0: CI fix — upload manifests as release assets
- [x] Phase 1: Add `serde::Deserialize` to artefact newtypes
- [x] Phase 2: Add manifest parser module
- [x] Phase 3: Add extraction module
- [x] Phase 4: Add download module (requires `ureq` dependency)
- [x] Phase 5: Add prebuilt orchestrator module
- [x] Phase 6: CLI flag + modify `run_install()` flow
- [x] Phase 7: BDD tests for prebuilt download workflow
- [x] Phase 8: Update documentation and roadmap

## Surprises & discoveries

- Mock types generated by `mockall::automock` under `#[cfg(test)]` are not
  accessible from integration tests. BDD tests use hand-written stub
  implementations of `ArtefactDownloader` and `ArtefactExtractor` instead.

- The `prebuilt.rs` module exceeded 400 lines with inline tests. Tests
  were extracted to `prebuilt_tests.rs` using the `#[path = ...]` pattern.

- `attempt_prebuilt_with` was promoted from `pub(crate)` to `pub` to allow
  integration tests to inject stub dependencies.

- The `ureq` v3 API uses `ureq::Error::StatusCode(u16)` for HTTP errors
  (not a nested response type), simplifying the 404 detection path.

## Decision log

- Decision: Use `ureq` (v3) as HTTP client rather than `reqwest`.
  Rationale: `ureq` is synchronous with no async runtime dependency,
  matching the installer's blocking execution model. Much smaller
  dependency tree.
  Date: 2026-02-15 (plan phase).

- Decision: Use `PrebuiltResult` enum (Success/Fallback) rather than
  `Result<T, E>` for the orchestrator return type.
  Rationale: prebuilt failures are never fatal. An enum prevents callers
  from accidentally propagating errors with `?`.
  Date: 2026-02-15 (plan phase).

- Decision: Implement custom `Deserialize` for newtypes rather than
  deriving it.
  Rationale: `#[derive(Deserialize)]` on `#[serde(transparent)]`
  newtypes bypasses `TryFrom` validation, accepting invalid values.
  Custom impls route through existing validation.
  Date: 2026-02-15 (plan phase).

- Decision: Rename CI manifest output to `manifest-<target>.json`.
  Rationale: all 5 matrix jobs write `dist/manifest.json`; the
  `download-artifact` merge step would clobber all but the last.
  Target-qualified names prevent this.
  Date: 2026-02-15 (plan phase).

## Outcomes & retrospective

All 9 phases completed. The installer now implements the download-first
strategy from ADR-001:

- 4 new modules created: `download`, `extraction`, `manifest_parser`,
  `prebuilt`.
- 6 artefact newtypes and compound types gained `Deserialize` support.
- `--build-only` CLI flag added for opt-out.
- 6 unit tests in the prebuilt orchestrator covering all failure modes.
- 6 BDD scenarios in `prebuilt_download.feature` covering the end-to-end
  workflow.
- CI workflow updated to upload target-specific manifests.
- ADR-001 and roadmap updated.

All constraints respected: no file exceeds 400 lines, no breaking changes
to existing public APIs, en-GB-oxendict spelling throughout.

## Context and orientation

### Crate structure

The installer crate at `installer/` is a Cargo binary crate with two
binaries: `whitaker-installer` (main CLI) and `whitaker-package-lints`
(packaging CLI used by CI). The library root is `installer/src/lib.rs`.

### Key modules

- `installer/src/artefact/` — Domain model: `GitSha`, `ToolchainChannel`,
  `TargetTriple`, `Sha256Digest`, `SchemaVersion`, `ArtefactName`,
  `Manifest`, `VerificationPolicy`, `VerificationFailureAction`, plus
  packaging functions. Currently only `Serialize` is derived (not
  `Deserialize`).
- `installer/src/builder.rs` — `CrateBuilder` trait (mockable with
  `mockall`) and `Builder` impl. Established pattern for trait-based DI.
- `installer/src/pipeline.rs` — `PipelineContext`, `perform_build()`,
  `stage_libraries()`.
- `installer/src/main.rs` — `run_install()` orchestration (lines 55-101):
  deps → workspace → crates → toolchain → build → stage → wrapper.
- `installer/src/cli.rs` — `InstallArgs` struct with clap derive.
- `installer/src/error.rs` — `InstallerError` enum (thiserror).
- `installer/src/stager.rs` — `Stager` for file staging.

### CI workflow

`.github/workflows/rolling-release.yml` builds lint crates for a 5-target
matrix, packages each as `.tar.zst` using `whitaker-package-lints`, and
publishes to a `rolling` GitHub Release tag. Currently only `.tar.zst`
files are uploaded; `manifest.json` sidecar files are produced but not
uploaded.

### Testing patterns

BDD tests use rstest-bdd v0.5.0 mutable world pattern:
- World struct with `#[derive(Default)]`
- `#[fixture] fn world()` returning the default
- Step definitions via `given!`, `when!`, `then!` macros from
  `rstest_bdd_macros`
- Scenario bindings via `#[scenario(path = ..., name = ...)]`
- Feature files in `installer/tests/features/`

Unit tests use rstest fixtures, `#[case]` parameterisation, and mockall.

### Existing reusable code

- `artefact::packaging::compute_sha256(path)` — SHA-256 file hashing
  (8 KiB chunked). Reuse for verification.
- `artefact::naming::ArtefactName` — Deterministic archive filename
  construction. Reuse to derive expected download URL.
- `artefact::verification::VerificationPolicy` — Policy value type.
  Reuse to check whether checksumming is required.
- `output::write_stderr_line()` — Progress output helper.
- `CrateBuilder` trait pattern — Template for new mockable traits.

## Plan of work

### Phase 0: CI fix — upload manifests as release assets

The CI workflow must upload manifests alongside archives. Without this the
installer has no manifest to download.

Files to modify:
- `installer/src/bin/package_lints.rs` (~line 133): change output
  manifest filename from `manifest.json` to
  `manifest-<target>.json`.
- `.github/workflows/rolling-release.yml`:
  - Line 106: change upload glob from `dist/*.tar.zst` to `dist/*`
    (or add `dist/*.json` as a second path).
  - Line 143: change release create glob from `dist/*.tar.zst` to
    `dist/*`.

### Phase 1: Add `serde::Deserialize` to artefact newtypes

Add custom `Deserialize` implementations that route through existing
`TryFrom` validation for: `GitSha`, `ToolchainChannel`, `TargetTriple`,
`Sha256Digest`, `SchemaVersion`.

Add `#[derive(Deserialize)]` to compound types that compose validated
newtypes: `Manifest`, `ManifestProvenance`, `ManifestContent`,
`GeneratedAt`.

Pattern for each newtype (example `GitSha`):

    impl<'de> serde::Deserialize<'de> for GitSha {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let s = String::deserialize(deserializer)?;
            GitSha::try_from(s).map_err(serde::de::Error::custom)
        }
    }

For `SchemaVersion`, deserialize as `u32` then `TryFrom<u32>`.

Add round-trip unit tests (serialize then deserialize) and rejection tests
(deserialize invalid values) for each type.

If `manifest.rs` exceeds 400 lines, extract its `#[cfg(test)] mod tests`
to `manifest_tests.rs` using the `#[path = ...]` pattern.

Files to modify:
- `installer/src/artefact/git_sha.rs`
- `installer/src/artefact/toolchain_channel.rs`
- `installer/src/artefact/target.rs`
- `installer/src/artefact/sha256_digest.rs`
- `installer/src/artefact/schema_version.rs`
- `installer/src/artefact/manifest.rs`

### Phase 2: Add manifest parser module

Create `installer/src/artefact/manifest_parser.rs` (~60 lines).

    pub fn parse_manifest(json: &str) -> Result<Manifest, ManifestParseError>

    #[derive(Debug, thiserror::Error)]
    pub enum ManifestParseError {
        #[error("manifest parse error: {0}")]
        Json(#[from] serde_json::Error),
    }

Register in `installer/src/artefact/mod.rs`.

Unit tests: valid JSON, invalid JSON, invalid field values (schema version
99, bad target triple, bad SHA digest, missing fields).

### Phase 3: Add extraction module

Create `installer/src/artefact/extraction.rs` (~120 lines).

    #[cfg_attr(test, mockall::automock)]
    pub trait ArtefactExtractor {
        fn extract(
            &self,
            archive_path: &Path,
            dest_dir: &Path,
        ) -> Result<Vec<String>, ExtractionError>;
    }

    #[derive(Debug, thiserror::Error)]
    pub enum ExtractionError {
        #[error("extraction I/O error: {0}")]
        Io(#[from] std::io::Error),
        #[error("path traversal detected: {path}")]
        PathTraversal { path: String },
        #[error("archive contains no library files")]
        EmptyArchive,
    }

    pub struct ZstdExtractor;

Implementation: open file → zstd decode → tar unpack. Validate each
entry path has no `..` components and is not absolute (zip-slip
prevention). Collect and return extracted filenames.

Register in `installer/src/artefact/mod.rs`.

Unit tests: extract a real temp `.tar.zst`, path traversal rejection,
empty archive.

### Phase 4: Add download module

Add dependencies:
- Workspace `Cargo.toml`: `ureq = "3"`
- `installer/Cargo.toml` dependencies: `ureq = { workspace = true }`
- `installer/Cargo.toml` dependencies: promote `tempfile` from
  dev-dependencies to regular dependencies.

Create `installer/src/artefact/download.rs` (~150 lines).

    const GITHUB_REPO: &str = "leynos/whitaker";
    const ROLLING_TAG: &str = "rolling";

    #[cfg_attr(test, mockall::automock)]
    pub trait ArtefactDownloader {
        fn download_manifest(
            &self, target: &str,
        ) -> Result<String, DownloadError>;

        fn download_archive(
            &self, filename: &str, dest: &Path,
        ) -> Result<(), DownloadError>;
    }

    #[derive(Debug, thiserror::Error)]
    pub enum DownloadError {
        #[error("download failed for {url}: {reason}")]
        HttpError { url: String, reason: String },
        #[error("artefact not found: {url}")]
        NotFound { url: String },
        #[error("I/O error writing download: {0}")]
        Io(#[from] std::io::Error),
    }

    pub struct HttpDownloader;

`HttpDownloader` constructs URLs as:
`https://github.com/{GITHUB_REPO}/releases/download/{ROLLING_TAG}/{filename}`

For manifests the filename is `manifest-{target}.json`.
For archives the filename is the `ArtefactName::filename()` string.

Register in `installer/src/artefact/mod.rs`.

Unit tests: URL construction correctness. Integration tests use mocks.

### Phase 5: Add prebuilt orchestrator module

Create `installer/src/prebuilt.rs` (~200 lines).

    pub enum PrebuiltResult {
        Success { staging_path: Utf8PathBuf },
        Fallback { reason: String },
    }

    pub struct PrebuiltConfig<'a> {
        pub target: &'a str,
        pub toolchain: &'a str,
        pub staging_base: &'a Utf8Path,
        pub quiet: bool,
    }

    /// Production entry point.
    pub fn attempt_prebuilt(
        config: &PrebuiltConfig<'_>,
        stderr: &mut dyn Write,
    ) -> PrebuiltResult

    /// Testable inner with injected dependencies.
    pub(crate) fn attempt_prebuilt_with(
        config: &PrebuiltConfig<'_>,
        downloader: &dyn ArtefactDownloader,
        extractor: &dyn ArtefactExtractor,
        stderr: &mut dyn Write,
    ) -> PrebuiltResult

Internal pipeline:
1. Download manifest JSON for the target.
2. Parse manifest, validate toolchain matches local.
3. Derive archive filename from manifest fields.
4. Download archive to a `tempfile::tempdir()`.
5. If `VerificationPolicy::default().require_checksum()`, compute
   SHA-256 of downloaded archive using
   `artefact::packaging::compute_sha256()` and compare against
   `manifest.sha256()`.
6. Extract archive to `staging_base/<toolchain>/release/` using the
   extractor.
7. Return `PrebuiltResult::Success` with the staging path.

On any error, log a warning (unless quiet) and return
`PrebuiltResult::Fallback { reason }`.

Internal error type `PrebuiltError` (not exported) with variants:
`Download`, `ManifestParse`, `ChecksumMismatch`, `Extraction`, `Other`.

Register in `installer/src/lib.rs`.

Unit tests with `MockArtefactDownloader` + `MockArtefactExtractor`:
happy path, download failure, 404, checksum mismatch, extraction
failure, toolchain mismatch.

### Phase 6: CLI flag + modify `run_install()` flow

Add `--build-only` flag to `InstallArgs` in `installer/src/cli.rs`:

    /// Skip prebuilt artefact download and build from source.
    #[arg(long)]
    pub build_only: bool,

Update `Default` impl and add to boolean flag parameterised test.

Add host target detection in `installer/src/main.rs`:

    fn detect_host_target() -> Result<String> {
        // Run `rustc -vV`, parse `host: <triple>` line
    }

Modify `run_install()` to insert prebuilt attempt between step 3
(resolve crates/toolchain) and step 4 (build):

    // Step 3.5: Attempt prebuilt download
    if !args.build_only {
        let host_target = detect_host_target()?;
        let prebuilt_config = PrebuiltConfig {
            target: &host_target,
            toolchain: toolchain.channel(),
            staging_base: &target_dir,
            quiet: args.quiet,
        };
        match attempt_prebuilt(&prebuilt_config, stderr) {
            PrebuiltResult::Success { staging_path } => {
                // Skip build+stage, jump to wrapper generation
                if args.skip_wrapper { ... } else { ... }
                return Ok(());
            }
            PrebuiltResult::Fallback { .. } => {
                // Continue to local build
            }
        }
    }

Files to modify:
- `installer/src/cli.rs`
- `installer/src/main.rs`
- `installer/src/error.rs` (optional: add `PrebuiltFailed` variant
  if needed for dry-run reporting)

### Phase 7: BDD tests for prebuilt download workflow

Create `installer/tests/features/prebuilt_download.feature` (~50 lines):

    Feature: Prebuilt artefact download and verification

      Scenario: Successful prebuilt download and verification
        Given a valid manifest for target "x86_64-unknown-linux-gnu"
        And a matching archive with correct checksum
        When prebuilt download is attempted
        Then the prebuilt result is success
        And the staging path contains extracted libraries

      Scenario: Checksum mismatch triggers fallback
        Given a valid manifest for target "x86_64-unknown-linux-gnu"
        And an archive with mismatched checksum
        When prebuilt download is attempted
        Then the prebuilt result is fallback
        And the fallback reason mentions checksum

      Scenario: Network failure triggers fallback
        Given a manifest download that fails with a network error
        When prebuilt download is attempted
        Then the prebuilt result is fallback
        And the fallback reason mentions download

      Scenario: Missing artefact triggers fallback
        Given a manifest download that returns not found
        When prebuilt download is attempted
        Then the prebuilt result is fallback
        And the fallback reason mentions not found

      Scenario: Toolchain mismatch triggers fallback
        Given a valid manifest with toolchain "nightly-2025-01-01"
        And the expected toolchain is "nightly-2025-09-18"
        When prebuilt download is attempted
        Then the prebuilt result is fallback
        And the fallback reason mentions toolchain

      Scenario: Build-only flag skips prebuilt
        Given the build-only flag is set
        When the install command is configured
        Then no prebuilt download is attempted

Create `installer/tests/behaviour_prebuilt.rs` (~250 lines):
- `PrebuiltWorld` struct with fields for mock state, config, result.
- Step definitions using `MockArtefactDownloader` and
  `MockArtefactExtractor`.
- Scenario bindings to the feature file.

### Phase 8: Update documentation and roadmap

- `docs/roadmap.md`: mark 3.4.4 as `[x]`.
- `docs/adr-001-prebuilt-dylint-libraries.md`: add implementation notes
  section for task 3.4.4 covering:
  - Module structure (download, extraction, manifest_parser, prebuilt).
  - `ureq` choice rationale.
  - Custom `Deserialize` approach.
  - Manifest naming change (`manifest-<target>.json`).
  - `--build-only` CLI flag.
- `docs/whitaker-dylint-suite-design.md`: update if relevant sections
  need reflecting the prebuilt flow.

## Concrete steps

All commands run from `/home/user/project/`.

After each phase:

    set -o pipefail
    make check-fmt 2>&1 | tee /tmp/check-fmt.log
    make lint 2>&1 | tee /tmp/lint.log
    make test 2>&1 | tee /tmp/test.log

Expected: all three commands exit 0.

## Validation and acceptance

Quality criteria:

- Tests: `make test` passes. New unit tests cover round-trip
  serialization, manifest parsing (happy + unhappy), extraction (happy +
  path traversal + empty), prebuilt orchestration (happy + 5 failure
  modes), CLI flag parsing. New BDD scenarios in
  `prebuilt_download.feature` all pass.
- Lint: `make lint` passes (clippy workspace, all targets, all features,
  `-D warnings`).
- Format: `make check-fmt` passes.
- No file exceeds 400 lines.
- Roadmap 3.4.4 marked done.
- ADR-001 updated with implementation notes.

Quality method:

    make check-fmt && make lint && make test

## Idempotence and recovery

All phases produce additive changes. If a phase fails partway through,
fix the issue and re-run the quality gates. The `tempfile` crate ensures
downloaded archives are cleaned up on failure.

## Artifacts and notes

Key files created:
- `installer/src/artefact/manifest_parser.rs`
- `installer/src/artefact/download.rs`
- `installer/src/artefact/extraction.rs`
- `installer/src/prebuilt.rs`
- `installer/tests/features/prebuilt_download.feature`
- `installer/tests/behaviour_prebuilt.rs`

Key files modified:
- `installer/src/artefact/git_sha.rs` (add Deserialize)
- `installer/src/artefact/toolchain_channel.rs` (add Deserialize)
- `installer/src/artefact/target.rs` (add Deserialize)
- `installer/src/artefact/sha256_digest.rs` (add Deserialize)
- `installer/src/artefact/schema_version.rs` (add Deserialize)
- `installer/src/artefact/manifest.rs` (add Deserialize derives)
- `installer/src/artefact/mod.rs` (register new modules)
- `installer/src/lib.rs` (register prebuilt module)
- `installer/src/cli.rs` (add --build-only flag)
- `installer/src/main.rs` (insert prebuilt attempt)
- `installer/Cargo.toml` (add ureq, promote tempfile)
- `Cargo.toml` (add ureq to workspace deps)
- `.github/workflows/rolling-release.yml` (upload manifests)
- `installer/src/bin/package_lints.rs` (target-specific manifest name)
- `docs/roadmap.md` (mark 3.4.4 done)
- `docs/adr-001-prebuilt-dylint-libraries.md` (implementation notes)

## Interfaces and dependencies

### New traits

In `installer/src/artefact/download.rs`:

    #[cfg_attr(test, mockall::automock)]
    pub trait ArtefactDownloader {
        fn download_manifest(&self, target: &str)
            -> Result<String, DownloadError>;
        fn download_archive(&self, filename: &str, dest: &Path)
            -> Result<(), DownloadError>;
    }

In `installer/src/artefact/extraction.rs`:

    #[cfg_attr(test, mockall::automock)]
    pub trait ArtefactExtractor {
        fn extract(&self, archive_path: &Path, dest_dir: &Path)
            -> Result<Vec<String>, ExtractionError>;
    }

### New public types

In `installer/src/prebuilt.rs`:

    pub enum PrebuiltResult {
        Success { staging_path: Utf8PathBuf },
        Fallback { reason: String },
    }

    pub struct PrebuiltConfig<'a> {
        pub target: &'a str,
        pub toolchain: &'a str,
        pub staging_base: &'a Utf8Path,
        pub quiet: bool,
    }

### New dependency

    ureq = "3"  (workspace, caret requirement)
    tempfile promoted from dev-dep to regular dep in installer crate.
