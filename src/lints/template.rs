//! Helpers that generate boilerplate for Whitaker lint crates.
//!
//! The template encapsulates the canonical `Cargo.toml` manifest entries and the
//! baseline `src/lib.rs` source that wires in Whitaker's shared UI harness.
//! Lint authors can use this module to scaffold new crates without repeating the
//! dependency declarations or test boilerplate.

use std::fmt;

use camino::Utf8Path;
use toml::Value;

/// Files generated by [`LintCrateTemplate`].
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TemplateFiles {
    manifest: String,
    lib_rs: String,
}

impl TemplateFiles {
    /// Returns the generated `Cargo.toml` manifest.
    #[must_use]
    pub fn manifest(&self) -> &str {
        &self.manifest
    }

    /// Returns the generated `src/lib.rs` source.
    #[must_use]
    pub fn lib_rs(&self) -> &str {
        &self.lib_rs
    }

    /// Parses the manifest into a TOML [`Value`] for inspection.
    ///
    /// # Errors
    ///
    /// Returns the parse error when the generated manifest is not valid TOML.
    pub fn manifest_document(&self) -> Result<Value, toml::de::Error> {
        toml::from_str(self.manifest())
    }
}

/// Errors emitted when constructing a lint crate template.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum TemplateError {
    /// Crate names must not be empty or whitespace only.
    EmptyCrateName,
    /// Crate names must begin with an ASCII lowercase letter.
    InvalidCrateNameStart { character: char },
    /// Crate names may contain only ASCII lowercase letters, digits, `-`, or `_`.
    InvalidCrateNameCharacter { character: char },
    /// UI test directories must be provided.
    EmptyUiDirectory,
    /// UI test directories must be relative paths.
    AbsoluteUiDirectory { directory: String },
}

impl fmt::Display for TemplateError {
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::EmptyCrateName => formatter.write_str("crate name must not be empty"),
            Self::InvalidCrateNameStart { character } => write!(
                formatter,
                "crate name must begin with a lowercase ASCII letter (invalid `{character}`)"
            ),
            Self::InvalidCrateNameCharacter { character } => write!(
                formatter,
                "crate name may only contain lowercase ASCII letters, digits, '-' or '_' (invalid `{character}`)"
            ),
            Self::EmptyUiDirectory => formatter.write_str("UI test directory must not be empty"),
            Self::AbsoluteUiDirectory { directory } => {
                write!(formatter, "UI test directory must be relative: {directory}")
            }
        }
    }
}

impl std::error::Error for TemplateError {}

/// Template metadata for constructing a lint crate.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LintCrateTemplate {
    crate_name: String,
    lint_constant: String,
    pass_struct: String,
    ui_tests_directory: String,
}

impl LintCrateTemplate {
    /// Create a template using the default `ui` test directory.
    ///
    /// # Errors
    ///
    /// Returns [`TemplateError`] when the crate name is invalid.
    pub fn new(crate_name: impl AsRef<str>) -> Result<Self, TemplateError> {
        Self::with_ui_tests_directory(crate_name, "ui")
    }

    /// Create a template that points to a specific UI tests directory.
    ///
    /// # Errors
    ///
    /// Returns [`TemplateError`] when either the crate name or the directory are
    /// invalid.
    pub fn with_ui_tests_directory(
        crate_name: impl AsRef<str>,
        ui_tests_directory: impl AsRef<str>,
    ) -> Result<Self, TemplateError> {
        let name = normalise_crate_name(crate_name.as_ref())?;
        let lint_constant = lint_constant(&name);
        let pass_struct = pass_struct_name(&name);
        let ui_directory = normalise_ui_directory(ui_tests_directory.as_ref())?;

        Ok(Self {
            crate_name: name,
            lint_constant,
            pass_struct,
            ui_tests_directory: ui_directory,
        })
    }

    /// Returns the crate name used by the template.
    #[must_use]
    pub fn crate_name(&self) -> &str {
        &self.crate_name
    }

    /// Returns the lint constant derived from the crate name.
    #[must_use]
    pub fn lint_constant(&self) -> &str {
        &self.lint_constant
    }

    /// Returns the name of the lint pass struct.
    #[must_use]
    pub fn pass_struct(&self) -> &str {
        &self.pass_struct
    }

    /// Returns the UI tests directory used by the template.
    #[must_use]
    pub fn ui_tests_directory(&self) -> &str {
        &self.ui_tests_directory
    }

    /// Render the template into manifest and source files.
    #[must_use]
    pub fn render(&self) -> TemplateFiles {
        TemplateFiles {
            manifest: self.render_manifest(),
            lib_rs: self.render_lib_rs(),
        }
    }

    fn render_manifest(&self) -> String {
        format!(
            concat!(
                "[package]\n",
                "name = \"{crate_name}\"\n",
                "version = \"0.1.0\"\n",
                "edition = \"2021\"\n\n",
                "[lib]\n",
                "crate-type = [\"cdylib\"]\n\n",
                "[dependencies]\n",
                "dylint_linting = {{ workspace = true }}\n",
                "common = {{ path = \"../../common\" }}\n\n",
                "[dev-dependencies]\n",
                "whitaker = {{ path = \"../../\" }}\n",
            ),
            crate_name = self.crate_name,
        )
    }

    fn render_lib_rs(&self) -> String {
        format!(
            concat!(
                "//! Lint crate for `{crate_name}`.\n",
                "//!\n",
                "//! Replace the placeholder implementation with crate-specific logic before shipping.\n",
                "#![cfg_attr(feature = \"dylint-driver\", feature(rustc_private))]\n\n",
                "use dylint_linting::{{declare_late_lint, impl_late_lint}};\n",
                "use rustc_lint::{{LateContext, LateLintPass}};\n\n",
                "declare_late_lint!(\n",
                "    pub {lint},\n",
                "    Warn,\n",
                "    \"replace the message with a short lint description\",\n",
                ");\n\n",
                "pub struct {pass};\n\n",
                "impl_late_lint! {{\n",
                "    {lint},\n",
                "    {pass},\n\n",
                "    fn check_crate<'tcx>(\n",
                "        &mut self,\n",
                "        _cx: &LateContext<'tcx>,\n",
                "        _krate: &'tcx rustc_hir::Crate<'tcx>,\n",
                "    ) {{\n",
                "        // TODO: Update the lint implementation.\n",
                "    }}\n",
                "}}\n\n",
                "#[cfg(test)]\n",
                "mod tests {{\n",
                "    whitaker::declare_ui_tests!(\"{ui}\");\n",
                "}}\n",
            ),
            crate_name = self.crate_name,
            lint = self.lint_constant,
            pass = self.pass_struct,
            ui = self.ui_tests_directory,
        )
    }
}

fn normalise_crate_name(input: &str) -> Result<String, TemplateError> {
    let trimmed = input.trim();
    if trimmed.is_empty() {
        return Err(TemplateError::EmptyCrateName);
    }

    let mut characters = trimmed.chars();
    let Some(first) = characters.next() else {
        return Err(TemplateError::EmptyCrateName);
    };

    if !first.is_ascii_lowercase() {
        return Err(TemplateError::InvalidCrateNameStart { character: first });
    }

    for character in characters {
        if !(character.is_ascii_lowercase()
            || character.is_ascii_digit()
            || matches!(character, '-' | '_'))
        {
            return Err(TemplateError::InvalidCrateNameCharacter { character });
        }
    }

    Ok(trimmed.to_string())
}

fn lint_constant(crate_name: &str) -> String {
    crate_name
        .chars()
        .map(|character| match character {
            '-' | '_' => '_',
            other => other,
        })
        .map(|character| character.to_ascii_uppercase())
        .collect()
}

fn pass_struct_name(crate_name: &str) -> String {
    crate_name
        .split(['-', '_'])
        .filter(|segment| !segment.is_empty())
        .map(|segment| {
            let mut characters = segment.chars();
            let Some(first) = characters.next() else {
                return String::new();
            };

            let mut capitalised = String::new();
            capitalised.push(first.to_ascii_uppercase());
            for character in characters {
                capitalised.push(character.to_ascii_lowercase());
            }
            capitalised
        })
        .collect()
}

fn normalise_ui_directory(input: &str) -> Result<String, TemplateError> {
    let trimmed = input.trim();
    if trimmed.is_empty() {
        return Err(TemplateError::EmptyUiDirectory);
    }

    let path = Utf8Path::new(trimmed);
    if path.is_absolute() {
        return Err(TemplateError::AbsoluteUiDirectory {
            directory: trimmed.to_string(),
        });
    }

    Ok(trimmed.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn constant_from_crate_name() {
        assert_eq!(
            lint_constant("module_max_400_lines"),
            "MODULE_MAX_400_LINES"
        );
        assert_eq!(
            lint_constant("no-expect-outside-tests"),
            "NO_EXPECT_OUTSIDE_TESTS"
        );
    }

    #[test]
    fn pass_struct_from_crate_name() {
        assert_eq!(
            pass_struct_name("module_max_400_lines"),
            "ModuleMax400Lines"
        );
        assert_eq!(
            pass_struct_name("no-expect-outside-tests"),
            "NoExpectOutsideTests"
        );
    }

    #[test]
    fn template_rejects_invalid_crate_name() {
        let Err(error) = LintCrateTemplate::new("1invalid") else {
            panic!("invalid crate names should be rejected");
        };
        assert_eq!(
            error,
            TemplateError::InvalidCrateNameStart { character: '1' }
        );
    }

    #[test]
    fn template_rejects_absolute_ui_directory() {
        let Err(error) =
            LintCrateTemplate::with_ui_tests_directory("module_max_400_lines", "/tmp/ui")
        else {
            panic!("absolute UI directories should be rejected");
        };
        assert_eq!(
            error,
            TemplateError::AbsoluteUiDirectory {
                directory: "/tmp/ui".to_string(),
            }
        );
    }

    #[test]
    fn render_builds_manifest_and_source() {
        let Ok(template) = LintCrateTemplate::new("function_attrs_follow_docs") else {
            panic!("failed to build template");
        };
        let files = template.render();
        let manifest = files
            .manifest_document()
            .unwrap_or_else(|error| panic!("manifest should parse: {error}"));

        assert!(
            manifest
                .get("dependencies")
                .and_then(Value::as_table)
                .and_then(|dependencies| dependencies.get("dylint_linting"))
                .is_some()
        );
        assert!(
            files
                .lib_rs()
                .contains("whitaker::declare_ui_tests!(\"ui\");")
        );
    }
}
