//! Helpers that generate boilerplate for Whitaker lint crates.
//!
//! The template encapsulates the canonical `Cargo.toml` manifest entries and the
//! baseline `src/lib.rs` source that wires in Whitaker's shared UI harness.
//! Lint authors can use this module to scaffold new crates without repeating the
//! dependency declarations or test boilerplate.

mod content;
mod validation;

use std::fmt;

use content::{render_lib_rs, render_manifest};
use validation::{lint_constant, normalise_crate_name, normalise_ui_directory, pass_struct_name};

/// Files generated by [`LintCrateTemplate`].
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct TemplateFiles {
    manifest: String,
    lib_rs: String,
}

impl TemplateFiles {
    /// Returns the generated `Cargo.toml` manifest.
    ///
    /// # Examples
    ///
    /// ```
    /// use whitaker::lints::LintCrateTemplate;
    ///
    /// let files = LintCrateTemplate::new("demo_lint")
    ///     .expect("valid crate name")
    ///     .render();
    ///
    /// assert!(files.manifest().contains("name = \"demo_lint\""));
    /// ```
    #[must_use]
    pub fn manifest(&self) -> &str {
        &self.manifest
    }

    /// Returns the generated `src/lib.rs` source.
    ///
    /// # Examples
    ///
    /// ```
    /// use whitaker::lints::LintCrateTemplate;
    ///
    /// let files = LintCrateTemplate::new("demo_lint")
    ///     .expect("valid crate name")
    ///     .render();
    ///
    /// assert!(files.lib_rs().contains("pub struct DemoLint"));
    /// ```
    #[must_use]
    pub fn lib_rs(&self) -> &str {
        &self.lib_rs
    }

    /// Parses the manifest into a TOML [`toml::Value`] for inspection.
    ///
    /// # Errors
    ///
    /// Returns the parse error when the generated manifest is not valid TOML.
    ///
    /// # Examples
    ///
    /// ```
    /// use whitaker::lints::LintCrateTemplate;
    ///
    /// let files = LintCrateTemplate::new("demo_lint")
    ///     .expect("valid crate name")
    ///     .render();
    /// let manifest = files
    ///     .manifest_document()
    ///     .expect("generated manifest parses");
    ///
    /// assert_eq!(
    ///     manifest["package"]["name"].as_str(),
    ///     Some("demo_lint")
    /// );
    /// ```
    pub fn manifest_document(&self) -> Result<toml::Value, toml::de::Error> {
        toml::from_str(self.manifest())
    }
}

/// Errors emitted when constructing a lint crate template.
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum TemplateError {
    /// Crate names must not be empty or whitespace only.
    EmptyCrateName,
    /// Crate names must begin with an ASCII lowercase letter.
    InvalidCrateNameStart { character: char },
    /// Crate names may contain only ASCII lowercase letters, digits, `-`, or `_`.
    InvalidCrateNameCharacter { character: char },
    /// Crate names must not end with a separator (`-` or `_`).
    CrateNameTrailingSeparator { character: char },
    /// UI test directories must be provided.
    EmptyUiDirectory,
    /// UI test directories must be relative paths.
    AbsoluteUiDirectory { directory: String },
    /// UI test directories must not traverse upwards.
    ParentUiDirectory { directory: String },
}

impl fmt::Display for TemplateError {
    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::EmptyCrateName => formatter.write_str("crate name must not be empty"),
            Self::InvalidCrateNameStart { character } => write!(
                formatter,
                "crate name must begin with a lowercase ASCII letter (invalid `{character}`)"
            ),
            Self::InvalidCrateNameCharacter { character } => write!(
                formatter,
                "crate name may only contain lowercase ASCII letters, digits, '-' or '_' (invalid `{character}`)"
            ),
            Self::CrateNameTrailingSeparator { character } => write!(
                formatter,
                "crate name must not end with '-' or '_' (invalid trailing `{character}`)"
            ),
            Self::EmptyUiDirectory => formatter.write_str("UI test directory must not be empty"),
            Self::AbsoluteUiDirectory { directory } => {
                write!(formatter, "UI test directory must be relative: {directory}")
            }
            Self::ParentUiDirectory { directory } => {
                write!(
                    formatter,
                    "UI test directory must not contain '..': {directory}"
                )
            }
        }
    }
}

impl std::error::Error for TemplateError {}

/// Template metadata for constructing a lint crate.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct LintCrateTemplate {
    crate_name: String,
    lint_constant: String,
    pass_struct: String,
    ui_tests_directory: String,
}

impl LintCrateTemplate {
    /// Create a template using the default `ui` test directory.
    ///
    /// # Errors
    ///
    /// Returns [`TemplateError`] when the crate name is invalid.
    pub fn new(crate_name: impl AsRef<str>) -> Result<Self, TemplateError> {
        Self::with_ui_tests_directory(crate_name, "ui")
    }

    /// Create a template that points to a specific UI tests directory.
    ///
    /// # Errors
    ///
    /// Returns [`TemplateError`] when either the crate name or the directory are
    /// invalid.
    pub fn with_ui_tests_directory(
        crate_name: impl AsRef<str>,
        ui_tests_directory: impl AsRef<str>,
    ) -> Result<Self, TemplateError> {
        let name = normalise_crate_name(crate_name.as_ref())?;
        let lint_constant = lint_constant(&name);
        let pass_struct = pass_struct_name(&name);
        let ui_directory = normalise_ui_directory(ui_tests_directory.as_ref())?;

        Ok(Self {
            crate_name: name,
            lint_constant,
            pass_struct,
            ui_tests_directory: ui_directory,
        })
    }

    /// Returns the crate name used by the template.
    #[must_use]
    pub fn crate_name(&self) -> &str {
        &self.crate_name
    }

    /// Returns the lint constant derived from the crate name.
    #[must_use]
    pub fn lint_constant(&self) -> &str {
        &self.lint_constant
    }

    /// Returns the name of the lint pass struct.
    #[must_use]
    pub fn pass_struct(&self) -> &str {
        &self.pass_struct
    }

    /// Returns the UI tests directory used by the template.
    #[must_use]
    pub fn ui_tests_directory(&self) -> &str {
        &self.ui_tests_directory
    }

    /// Render the template into manifest and source files.
    #[must_use]
    pub fn render(&self) -> TemplateFiles {
        let manifest = render_manifest(&self.crate_name);
        let lib_rs = render_lib_rs(
            &self.crate_name,
            &self.lint_constant,
            &self.pass_struct,
            &self.ui_tests_directory,
        );

        TemplateFiles { manifest, lib_rs }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use toml::Value;

    #[test]
    fn template_rejects_invalid_crate_name() {
        let Err(error) = LintCrateTemplate::new("1invalid") else {
            panic!("invalid crate names should be rejected");
        };
        assert_eq!(
            error,
            TemplateError::InvalidCrateNameStart { character: '1' }
        );
    }

    #[test]
    fn template_rejects_trailing_separator() {
        let Err(error) = LintCrateTemplate::new("lint_") else {
            panic!("trailing separators should be rejected");
        };
        assert_eq!(
            error,
            TemplateError::CrateNameTrailingSeparator { character: '_' }
        );
    }

    #[test]
    fn template_rejects_absolute_ui_directory() {
        let Err(error) =
            LintCrateTemplate::with_ui_tests_directory("module_max_400_lines", "/tmp/ui")
        else {
            panic!("absolute UI directories should be rejected");
        };
        assert_eq!(
            error,
            TemplateError::AbsoluteUiDirectory {
                directory: "/tmp/ui".to_string(),
            }
        );
    }

    #[test]
    fn template_rejects_parent_directory_in_ui_directory() {
        let Err(error) =
            LintCrateTemplate::with_ui_tests_directory("module_max_400_lines", "ui/../secrets")
        else {
            panic!("parent directory traversal should be rejected");
        };
        assert_eq!(
            error,
            TemplateError::ParentUiDirectory {
                directory: "ui/../secrets".to_string(),
            }
        );
    }

    #[test]
    fn render_builds_manifest_and_source() {
        let Ok(template) = LintCrateTemplate::new("function_attrs_follow_docs") else {
            panic!("failed to build template");
        };
        let files = template.render();
        let manifest = files
            .manifest_document()
            .unwrap_or_else(|error| panic!("manifest should parse: {error}"));

        assert!(
            manifest
                .get("dependencies")
                .and_then(Value::as_table)
                .and_then(|dependencies| dependencies.get("dylint_linting"))
                .is_some()
        );
        assert!(
            files
                .lib_rs()
                .contains("whitaker::declare_ui_tests!(\"ui\");")
        );
    }
}
